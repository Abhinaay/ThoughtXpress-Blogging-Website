{"version":3,"file":"w-ng5.js","sources":["ng:/w-ng5/out/src/app/pipes/filter.pipe.ts","ng:/w-ng5/out/src/app/pipes/pipes.module.ts"],"names":[],"mappings":";;;;;;AAAA;AAAI;AAAW;AAAI;;AAWnB,MAAA,UAAA,CAAA;AAAE;AAAQ;AAAyB;AAE3B;AAAmB;AAAQ,IAAjC,SAAS,CAAC,MAAa,EAAE,MAAW,EAAtC;AAAE,QAEE,IAAI,MAAM,YAAY,KAAK,EAAE;AACjC,YAAM,OAAO,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AACnD,SAAK;AAAC,aAAK;AACX,YAAM,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAClD,SAAK;AACL,KAAG;AACH;AACO;AAAyB;AAC7B;AAAmB;AACtB,IAFU,eAAe,CAAC,MAAM,EAAE,MAAW,EAA7C;AAAE,QACE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE;AAC5B,YAAM,OAAO,MAAM,CAAC;AACpB,SAAK;AACL,QAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAChH;AAEC;AAAQ;AAAyB;AAAyB;AAEpD;AAAQ,IAFL,gBAAgB,CAAC,MAAM,EAAE,MAA0B,EAA7D;AAAE,QAEE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACnD,YAAM,OAAO,MAAM,CAAC;AACpB,SAAK;AACL,QACI,uBAAM,MAAM,GAAG,EAAE,CAAC;AACtB;AAEG,QAAC,MAAM,CAAC,OAAO,CAAC,GAAG,IAAtB;AAAE,YACI,qBAAI,KAAK,GAAG,KAAK,CAAC;AACxB;AACM,YAAA,MAAM,CAAC,OAAO,CAAE,KAAK,IAA3B;AAAE,gBACM,KAAK,GAAG,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;AACrD,aAAO,CAAC,CAAC;AACT,YAAM,IAAI,KAAK,EAAE;AACjB,gBAAQ,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACzB,aAAO;AACP,SAAK,CAAC,CAAC;AACP,QACI,OAAO,MAAM,CAAC;AAClB;AAGA;AAAQ;AAAuB;AACrB;AAAmB;AAAQ,IAD3B,UAAU,CAAC,IAAI,EAAE,MAAM,EAAjC;AAAE,QACE,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,MAAM,CAAC,KAAK,KAAK,EAAE,EAAE;AAC1E,YAAM,OAAO,IAAI,CAAC;AAClB,SAAK;AACL,QAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;AACrC,YAAM,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;AAC/D;AACM,SAAD;AAAC,aAAK;AACX,YAAM,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;AAC9B,gBAAU,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;AACnH,aAAO;AAAC,iBAAK;AACb,gBAAU,OAAO,KAAK,CAAC;AACvB,aAAO;AACP,SAAK;AACL;AAEC;AAAQ;AAA4B;AAClC;AAAyB;AACnB;AAAQ,IAFP,UAAU,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAA9C;AAAE,QACE,uBAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACrC,QAAI,OAAO,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC;AAC9D;AAEC;AAAQ;AAAuB;AACzB;AAAQ,IADL,QAAQ,CAAC,IAAY,EAA/B;AAAE,QACE,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAClC;AAEC;AAAQ;AAAsB;AAAyB;AACpD;AAA4B;AACd;AAAQ,IAFhB,eAAe,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,SAAiB,EAAnE;AAAE;AAAqC,QAEnC,uBAAM,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;AAC1C;AACI,QAAA,IAAI,SAAS,KAAK,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;AAC5C;AACM,YAAA,IAAI,GAAG,EAAE;AACf,gBAAQ,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;AAC5F,aAAO;AAAC,iBAAK;AACb,gBAAQ,OAAO,KAAK,CAAC;AACrB,aAAO;AACP;AACQ,SAAH;AAAC,aAAK,IAAI,GAAG,EAAE;AACpB,YAAM,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,CAAC,CAAC;AACvE;AACQ,SAAH;AAAC,aAAK;AACX,YAAM,OAAO,KAAK,CAAC;AACnB,SAAK;AACL;AAEC;8BA3FD,EAAA,IAAA,EAAC,IAAI,EAAL,IAAA,EAAA,CAAM,kBACJ,IAAI,EAAE,QAAQ;eACd,IAAI,EAAE,IAAI,cACX,EAAD,EAAA;;;;;;;0BACC;AAAC;AAAC;AAAI;AAAkC;AAEX;AC8F9B,MAAA,WAAA,CAAA;AAAE;+BALF,EAAA,IAAA,EAAC,QAAQ,EAAT,IAAA,EAAA,CAAU;OACR,YAAY,EAAE,CAAC,UAAU,CAAC,kBAC1B,OAAO,EAAE,CAAC,UAAU,CAAC,kBACrB,SAAS,EAAE,CAAC,UAAU,CAAC,cACxB,EAAD,EAAA;;;;;;;;;0BACC;AAAC;AAAC;AAAI;AACK;AAAyC;AAAI;AAAC;AAAI;AAAkC;AAAyC;AAAI;AAAI;AAAwC;AAAI;AAAC;AAAoC","sourcesContent":["import { Pipe, PipeTransform } from '@angular/core';\r\n\r\nexport interface FilterParam {\r\n  field: string;\r\n  value: string;\r\n}\r\n\r\n@Pipe({\r\n  name: 'filter',\r\n  pure: true\r\n})\r\nexport class FilterPipe implements PipeTransform {\r\n\r\n  transform(values: any[], filter: any): any {\r\n\r\n    if (filter instanceof Array) {\r\n      return this.checkComplexType(values, filter);\r\n    } else {\r\n      return this.checkSimpleType(values, filter);\r\n    }\r\n  }\r\n\r\n  private checkSimpleType(values, filter: any): any {\r\n    if (!values || !filter) {\r\n      return values;\r\n    }\r\n    return values.filter(item => item.toString().toLowerCase().indexOf(filter.toString().toLowerCase()) !== -1);\r\n  }\r\n\r\n  private checkComplexType(values, filter: Array<FilterParam>): any {\r\n\r\n    if (!values || !filter || filter.length === 0) {\r\n      return values;\r\n    }\r\n\r\n    const result = [];\r\n\r\n    // find in all records\r\n    values.forEach(row => {\r\n      let match = false;\r\n      // find in all filters in the array of filters\r\n      filter.forEach( field => {\r\n        match = match || this.checkValue(row, field);\r\n      });\r\n      if (match) {\r\n        result.push(row); // add row in return\r\n      }\r\n    });\r\n\r\n    return result;\r\n\r\n  }\r\n\r\n  private checkValue(item, filter): boolean {\r\n    if (!filter || !filter.field || !filter.value || filter.value === '') {\r\n      return true;\r\n    }\r\n    if (this.existDot(filter.field)) {\r\n      return this.parseValue(item, filter.value, filter.field);\r\n      // return false;\r\n    } else {\r\n      if (item[filter.field]) {\r\n          return item[filter.field].toString().toLowerCase().indexOf(filter.value.toString().toLowerCase()) !== -1;\r\n      } else {\r\n          return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  private parseValue(reference, search, filter): boolean {\r\n    const fields = filter.split('.');\r\n    return this.existFieldValue(reference, search, fields, 0);\r\n  }\r\n\r\n  private existDot(path: string): boolean {\r\n    return path.indexOf('.') > -1;\r\n  }\r\n\r\n  private existFieldValue(obj, search, fieldFind, indexFind: number): boolean {\r\n    // Lê o valor da propriedade\r\n    const ref = obj[fieldFind[indexFind]];\r\n    // Se estiver no último nível...\r\n    if (indexFind === fieldFind.length - 1) {\r\n      // Se tiver valor, confere se contém o que está procurando...\r\n      if (ref) {\r\n        return ref.toString().toLowerCase().indexOf(search.toString().toLowerCase()) !== -1;\r\n      } else {\r\n        return false;\r\n      }\r\n    // Não está no último nível mas há valor na referência\r\n    } else if (ref) {\r\n      return this.existFieldValue(ref, search, fieldFind, ++indexFind);\r\n    // Não está no último nível e não há valor na referência (null)\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n}\r\n","import { Pipe, PipeTransform, NgModule } from '@angular/core';\r\n\r\nimport { FilterPipe } from './filter.pipe';\r\n/*\r\nexport interface FilterParam {\r\n  field: string;\r\n  value: string;\r\n}\r\n\r\n@Pipe({\r\n  name: 'filter',\r\n  pure: true\r\n})\r\nexport class FilterPipe implements PipeTransform {\r\n\r\n  transform(values: any[], filter: any): any {\r\n\r\n    if (filter instanceof Array) {\r\n      return this.checkComplexType(values, filter);\r\n    } else {\r\n      return this.checkSimpleType(values, filter);\r\n    }\r\n  }\r\n\r\n  private checkSimpleType(values, filter: any): any {\r\n    if (!values || !filter) {\r\n      return values;\r\n    }\r\n    return values.filter(item => item.toString().toLowerCase().indexOf(filter.toString().toLowerCase()) !== -1);\r\n  }\r\n\r\n  private checkComplexType(values, filter: Array<FilterParam>): any {\r\n\r\n    if (!values || !filter || filter.length === 0) {\r\n      return values;\r\n    }\r\n\r\n    const result = [];\r\n\r\n    // find in all records\r\n    values.forEach(row => {\r\n      let match = false;\r\n      // find in all filters in the array of filters\r\n      filter.forEach( field => {\r\n        match = match || this.checkValue(row, field);\r\n      });\r\n      if (match) {\r\n        result.push(row); // add row in return\r\n      }\r\n    });\r\n\r\n    return result;\r\n\r\n  }\r\n\r\n  private checkValue(item, filter): boolean {\r\n    if (!filter || !filter.field || !filter.value || filter.value === '') {\r\n      return true;\r\n    }\r\n    if (this.existDot(filter.field)) {\r\n      return this.parseValue(item, filter.value, filter.field);\r\n      // return false;\r\n    } else {\r\n      if (item[filter.field]) {\r\n          return item[filter.field].toString().toLowerCase().indexOf(filter.value.toString().toLowerCase()) !== -1;\r\n      } else {\r\n          return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  private parseValue(reference, search, filter): boolean {\r\n    const fields = filter.split('.');\r\n    return this.existFieldValue(reference, search, fields, 0);\r\n  }\r\n\r\n  private existDot(path: string): boolean {\r\n    return path.indexOf('.') > -1;\r\n  }\r\n\r\n  private existFieldValue(obj, search, fieldFind, indexFind: number): boolean {\r\n    // Lê o valor da propriedade\r\n    const ref = obj[fieldFind[indexFind]];\r\n    // Se estiver no último nível...\r\n    if (indexFind === fieldFind.length - 1) {\r\n      // Se tiver valor, confere se contém o que está procurando...\r\n      if (ref) {\r\n        return ref.toString().toLowerCase().indexOf(search.toString().toLowerCase()) !== -1;\r\n      } else {\r\n        return false;\r\n      }\r\n    // Não está no último nível mas há valor na referência\r\n    } else if (ref) {\r\n      return this.existFieldValue(ref, search, fieldFind, ++indexFind);\r\n    // Não está no último nível e não há valor na referência (null)\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n}*/\r\n\r\n@NgModule({\r\n  declarations: [FilterPipe],\r\n  exports: [FilterPipe],\r\n  providers: [FilterPipe]\r\n})\r\nexport class PipesModule { }\r\n"]}